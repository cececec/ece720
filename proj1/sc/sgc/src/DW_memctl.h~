/*****************************************************************************

The following code is derived, directly or indirectly, from the SystemC
source code Copyright (c) 1996-2008 by all Contributors.
All Rights reserved.

The contents of this file are subject to the restrictions and limitations
set forth in the SystemC Open Source License Version 3.0 (the "License");
You may not use this file except in compliance with such restrictions and
limitations. You may obtain instructions on how to receive a copy of the
License at http://www.systemc.org/. Software distributed by Contributors
under the License is distributed on an "AS IS" basis, WITHOUT WARRANTY OF
ANY KIND, either express or implied. See the License for the specific
language governing rights and limitations under the License.

*****************************************************************************/
//dw.target_socket same as s.slave   
//dw.source_socket same as bus.master
#ifndef __DWMEMCTL_H__
#define __DWMEMCTL_H__

#include "tlm.h"
#include "tlm_utils/simple_target_socket.h"
#include "tlm_utils/simple_initiator_socket.h"
#include<queue>

template <int NR_OF_INITIATORS, int NR_OF_TARGETS>
class DWmemctl : public sc_core::sc_module
{
public:
  typedef tlm::tlm_generic_payload transaction_type;
  typedef tlm::tlm_phase phase_type;
  typedef tlm::tlm_sync_enum sync_enum_type;
  typedef tlm_utils::simple_target_socket<DWmemctl> target_socket_type;//same as slave <mem>
  typedef tlm_utils::simple_initiator_socket_tagged<DWmemctl> initiator_socket_type;//same as master.initiator

public:
  target_socket_type  target_socket[NR_OF_INITIATORS];//same as mem.h -> slave
  initiator_socket_type initiator_socket[NR_OF_TARGETS];

public:
  char *subcommandsetstr[]; //= {"NOP", "READ", "WRITE", "PRECHARGE", "ACTIVE"};
  enum subcommand_set {NOP=0, READ, WRITE, PRECHARGE, ACTIVE};
  enum subcommand_set subcommand;
  std::queue<subcommand_set> chopboard;
  std::queue<subcommand_set> showcase;
  enum subcommand_set last_subcommand;
  sc_dt::uint64  last_address;
  sc_core::sc_time dw_start_time;
  sc_core::sc_time cmd_time; 
  sc_core::sc_time CLK,INT,SRAM_INIT,CAS,RAS,RCD,RP,WR,RCAR,XSR,RC,XP,WTR,DQSS,MRD;
  sc_core::sc_time reset_time, begin_of_burst,end_of_burst;
  int a10,auto_pre,notactive[4];
  int rw,ww,wr,rr,rws,rwd,rwdb,wwd,wws,wwdb,wrd,wrs,wrdb,rrd,rrs,rrdb;
    //sc_core::sc_time RRD   (*CLK); 
public:
  unsigned int data_bit_width;
  unsigned int burst_length;
 
public:
  SC_HAS_PROCESS(DWmemctl);
  DWmemctl(sc_core::sc_module_name name) :
    sc_core::sc_module(name)
  {
    for (unsigned int i = 0; i < NR_OF_INITIATORS; ++i) {
      target_socket[i].register_b_transport(this, &DWmemctl::initiatorBTransport);
      target_socket[i].register_transport_dbg(this, &DWmemctl::transportDebug);
    }
    
    // subcommandsetstr[]  
    last_subcommand = READ;
    last_address = 0x3ffff;
    data_bit_width=32;//bits
    sc_core::sc_time clock_cycle(10,sc_core::SC_NS);
    CLK=clock_cycle;
    rwd=wwd=wrd=rrd=rws=wws=wrs=rrs=rwdb=wwdb=wrdb=rrdb=rw=ww=wr=rr=0;
    a10=auto_pre=0;
    for(int i=0;i<4;i++) notactive[i]=1;
    //MRD(load mode register);INT(internal delay)
    WTR=CLK; INT=CAS=RCD=WR=DQSS=MRD=2*CLK;RP=3*CLK;//RAS_MIN
    RAS=XP=5*CLK;RC=7*CLK;SRAM_INIT=RCAR=8*CLK;reset_time=102*CLK;XSR =200*CLK;    
  }//Constructor 
  

  
  
void initiatorBTransport ( transaction_type &trans, sc_core::sc_time &t )//int SocketId, 
{
    initiator_socket_type* decodeSocket;
    decodeSocket = &initiator_socket[0];
    resetProc();
    unsigned int     length  = trans.get_data_length();
    tlm::tlm_command command = trans.get_command();
    sc_dt::uint64    address = trans.get_address();
    //char *subcommandsetstr[] = {"NOP", "READ", "WRITE", "PRECHARGE", "ACTIVE"};
    dw_start_time = sc_core::sc_time_stamp();
    
    sc_dt::uint64 this_bank, this_row, this_col;
    sc_dt::uint64 last_bank, last_row, last_col;
    this_bank = getBankNum(address);
    this_row  = getRowNum (address);
    this_col  = getColNum (address);
    last_bank = getBankNum(last_address);
    last_row  = getRowNum (last_address);
    last_col  = getColNum (last_address);
    std::cout << std::hex <<"Bank is " << this_bank << " Row  is " << this_row << " colnum is " << this_col << std::dec <<std::endl;
        if (address == 0x40000000) {
          std::cout << "=========================================";
          std::cout << "========================================="<< a10 << std::endl;
            std::cout <<"rws" <<rws <<" rwd" <<rwd<<" rwdb" <<rwdb<<" wwd" <<wwd<<" wws" << wws <<" wwdb" << wwdb;
            std::cout <<" wrd" <<wrd<<" wrs" <<wrs<<" wrdb" <<wrdb<<" rrd" <<rrd<<" rrs" << rrs <<" rrdb" << rrdb;
            std::cout << std::endl;
          std::cout << "=========================================";
          std::cout << "========================================="<< std::endl;
          }
     if (((address>>10)&1)==1) {std::cout << "+++++++++++++++++++++++++++"<< std::endl;a10++; auto_pre=1;} else auto_pre=0;
     int rp_flag=0;//check every time see if rp is done
     if (notactive[this_bank]) { wait(RP); notactive[this_bank]=0; rp_flag=1;}
     
     if (command == tlm::TLM_READ_COMMAND){             // ACTIVE to COMMAND to data_shown
       switch (last_subcommand){
         case READ:                       			  //Rd -> Rd
         {
           if(last_bank==this_bank){            					 //same bank
             if(last_row!=this_row) { 							 //different row 
                 if(rp_flag) cmd_time=(RCD+CAS); 
                 else cmd_time=RAS+RP+RCD+CAS;
                 rrd++; 
             }    			
             else { cmd_time=(CAS);rrs++;}                				 //same row
           }
           else { if(rp_flag) cmd_time=(RCD+CAS); else cmd_time=(RP+RCD+CAS);rrdb++;}    //different bank
           break;
         }
         case WRITE:                        			  //Wr -> Rd
         {
           if(last_bank==this_bank){          				 		 //same bank
             if(last_row!=this_row){							 //different row  
                if(rp_flag) cmd_time = (RCD+CAS);
                else cmd_time =(RAS+RP+RCD+CAS);
                wrd++;
             }    		
             else { cmd_time=(WTR+CAS);wrs++;}               				 //same row ???
           }                                 
           else { if(rp_flag) cmd_time=(RCD+CAS); else cmd_time=(RP+RCD+CAS); wrdb++;} //different bank
           last_subcommand=READ;                   				 	
           break;
         }
         default:{ cmd_time=(RP+RCD);std::cout << "!!!!!!!" << std::endl;}      
       }
    }
    else if (command == tlm::TLM_WRITE_COMMAND){ 
       switch (last_subcommand){
         case READ:                          			  //Rd -> Wr
         {
           if(last_bank==this_bank){             					 //same bank
             if(last_row!=this_row){ 							 //different row 
               if(rp_flag) cmd_time = (RCD+DQSS);
               else cmd_time=(RAS+RP+RCD+DQSS);
               rwd++;
             }     	
             else { cmd_time=(sc_core::SC_ZERO_TIME);rws++;}                  		 //same row ??
           }
           else { if(rp_flag) cmd_time=(RCD+DQSS); else cmd_time=(RP+RCD+DQSS); rwdb++;} //different bank
           last_subcommand=WRITE;                 	
           break;
         }
         case WRITE:                        			  //Wr -> Wr
         {
           if(last_bank==this_bank){                                                     //same bank
             if(last_row!=this_row){ 							 //different row
               if(rp_flag) cmd_time = (RCD+DQSS);
               else cmd_time=(RAS+RP+RCD+DQSS);
               wwd++; 
             }       
             else { cmd_time=(DQSS);wws++;}          					 //same row
           }                                 
           else { if(rp_flag) cmd_time=(RCD+DQSS); else cmd_time=(RP+RCD+DQSS); wwdb++;}  //different bank
           break;
         }
         default:{ cmd_time=(RP+RCD);std::cout << "!!!!!!!" << std::endl;}        
     
      }
    }
    wait(cmd_time);
    
    if(auto_pre){ // A10 is high
      if(command == tlm::TLM_WRITE_COMMAND){ 
        wait(WR);  
      }
      if((sc_core::sc_time_stamp()-dw_start_time) < RAS)
        wait (RAS+dw_start_time-sc_core::sc_time_stamp());
      for(int i=0;i<4;i++) notactive[i]=1;
      auto_pre=0;
    }
    
    
    
    if (length>(data_bit_width/8)){ 
      trans.set_data_length(4);//data_bit_width/8
      for (unsigned int i=0; i<length/(data_bit_width/8);i++){           //Regarding bugs in Cortex 
       (*decodeSocket)->b_transport(trans, t);      
        if(trans.get_command() == tlm::TLM_READ_COMMAND) wait(CAS+INT);
        //else;     
        trans.set_data_ptr(trans.get_data_ptr()+4);
        trans.set_address(trans.get_address()+4);        
      }  
      last_subcommand=WRITE;       
    }//Burst
    else{
      //scheduler(trans);
      (*decodeSocket)->b_transport(trans, t);
    }//Non-Burst
   
   
   last_address=address;
   
    
}//b_transport



void scheduler( transaction_type &gp ) {
  sc_dt::uint64 address; 
  unsigned long length; 
  int numofread;
 
 }//scheduler
 
 
  sc_dt::uint64 getAddressOffset(unsigned int portId)
  {
    return portId << 28;
  }

  sc_dt::uint64 getColNum (sc_dt::uint64 address){ return address & (0xfff); }
  sc_dt::uint64 getRowNum (sc_dt::uint64 address){ return (address>>3) & (0x1fff); } 
  sc_dt::uint64 getBankNum(sc_dt::uint64 address){ return (address >> 15) & (0x3); } 
  
void resetProc(){
 if (sc_core::sc_time_stamp()==sc_core::SC_ZERO_TIME){
    sc_core::wait(1005,sc_core::SC_NS);
    std::cout << sc_core::sc_time_stamp() << ": Memory Controller leaving startup..." << std::endl;
    sc_core::wait(CLK);
    std::cout << sc_core::sc_time_stamp() << ": Simulation leaving reset" << std::endl;
    wait((RP+MRD+XSR+SRAM_INIT)-reset_time);//Simulate Power-on Command Sequence(page 68) 
  }
}//reset
  
unsigned int transportDebug(transaction_type& trans)  { 
    initiator_socket_type* decodeSocket = &initiator_socket[0];    
    return (*decodeSocket)->transport_dbg(trans); 
}

};
#endif
