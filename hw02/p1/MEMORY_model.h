
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The MEMORY_pv will be derived from this class.
//*
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>


#pragma once

#include "model_builder.h"




#include "ahb_slave_protocol.h"

using namespace ::tlm;

class MEMORY_pv_base;
class MEMORY_pv_base_mb_compatibility : public mb::mb_module {
  friend class MEMORY_pv_base;
 public:
  typedef unsigned int mb_address_type;
 protected:
  MEMORY_pv_base_mb_compatibility(sc_module_name& module_name)
    : mb::mb_module(module_name) {}

  ////////////////////////////////////////
  // functions for target port: slave
  ////////////////////////////////////////
  protected:
   virtual bool slave_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     return true;
   }
   virtual bool slave_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     return true;
   }
   virtual unsigned slave_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     return 0;
   }
   virtual unsigned slave_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     return 0;
   }
   virtual bool slave_get_direct_memory_ptr(mb_address_type address,
                                                              tlm::tlm_dmi& dmiData) {
     return false;
   } 
};

class MEMORY_pv_base : public MEMORY_pv_base_mb_compatibility {
 private:
  typedef MEMORY_pv_base_mb_compatibility mb_compatibility_class;
 public:
  typedef esl::tlm_types::Address mb_address_type;
 public:
  typedef MEMORY_pv_base self;
  SC_HAS_PROCESS(MEMORY_pv_base);
  MEMORY_pv_base(sc_module_name& module_name);
  void print_parameters();
  
  enum port_enum {slave_idx };
  
 private:

  mb::tlm20::fw_process<tlm::tlm_base_protocol_types> m_slave_fw_process;

 protected:

  virtual void slave_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans, sc_core::sc_time& t) {
    bool status;

    if (mb_debug) {
      std::cout.unsetf(ios::showbase);
      bool isWrite = trans.is_write();
      unsigned char* data = trans.get_data_ptr();
      sc_dt::uint64 address = trans.get_address();
      unsigned size = trans.get_data_length();
      std::cout << this->name() << "::slave_callback_" <<
        (isWrite ? "write" : "read") << ", address = 0x" << std::hex << address;
      if (isWrite) {
        std::cout << ", data = {";
        std::cout << std::hex;
        for (unsigned u=0; u<size; u++) {
          std::cout << "0x" << (unsigned int)(data[u]);
          if (u+1 != size) {
            std::cout << ", ";
          }
        }
        std::cout << std::dec << "}";
      }
      std::cout << ", size = " << std::dec << size << std::endl;
    }
    
    if (trans.is_write()) {
      status = slave_callback_write(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      status = slave_callback_read(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      status = false;
    }
    trans.set_response_status(status ? TLM_OK_RESPONSE : TLM_GENERIC_ERROR_RESPONSE);
  }

  virtual unsigned slave_callback_dbg(tlm::tlm_base_protocol_types::tlm_payload_type& trans) {
    
    if (trans.is_write()) {
      return slave_callback_write_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else if (trans.is_read()) {
      return slave_callback_read_dbg(trans.get_address(), trans.get_data_ptr(), trans.get_data_length());
    } else {
      return 0;
    }
  }

  virtual bool slave_get_direct_memory_ptr_callback(tlm::tlm_base_protocol_types::tlm_payload_type& trans,
                                                                      tlm::tlm_dmi& dmiData) {
    if (trans.get_command() == tlm::TLM_IGNORE_COMMAND)
      return false;
    payload_on_stack = &trans;
    bool ret_value = slave_get_direct_memory_ptr(trans.get_address(), dmiData);
    payload_on_stack = 0;
    return ret_value;
  }

  

  

  

 protected:




  tlm::tlm_generic_payload* payload_on_stack;



  ////////////////////////////////////////
  // functions for target port: slave
  ////////////////////////////////////////
  protected:
   virtual bool slave_callback_read(mb_address_type address,
                                                      unsigned char* data,
                                                      unsigned size) {
     mb_compatibility_class *This = this;
     return This->slave_callback_read(mb_compatibility_class::mb_address_type(address),
                                                        data,
                                                        size);
   }
   virtual bool slave_callback_write(mb_address_type address,
                                                       unsigned char* data,
                                                       unsigned size) {
     mb_compatibility_class *This = this;
     return This->slave_callback_write(mb_compatibility_class::mb_address_type(address),
                                                         data,
                                                         size);
   }
   virtual unsigned slave_callback_read_dbg(mb_address_type address,
                                                              unsigned char* data,
                                                              unsigned size) {
     mb_compatibility_class *This = this;
     return This->slave_callback_read_dbg(mb_compatibility_class::mb_address_type(address),
                                                            data,
                                                            size);
   }
   virtual unsigned slave_callback_write_dbg(mb_address_type address,
                                                               unsigned char* data,
                                                               unsigned size) {
     mb_compatibility_class *This = this;
     return This->slave_callback_write_dbg(mb_compatibility_class::mb_address_type(address),
                                                             data,
                                                             size);
   }
   virtual bool slave_get_direct_memory_ptr(mb_address_type address, tlm::tlm_dmi& dmiData) {
     mb_compatibility_class *This = this;
     return This->slave_get_direct_memory_ptr(mb_compatibility_class::mb_address_type(address), dmiData);
   } 

   
  
  
 

 public:
  typedef tlm::tlm_base_protocol_types slave_protocol_types;
  typedef tlm::tlm_base_protocol_types::tlm_payload_type slave_payload_type;

 public:
  // port declarations 

  tlm::tlm_target_socket <32, tlm::tlm_base_protocol_types> slave;  

 
  
  

 protected:
  sc_core::sc_time clock;
  sc_core::sc_time ahb_slave_clock;
  double nominal_voltage;
  bool mb_debug;
  bool verbose_parameters;
  unsigned int slave_pipeline_length;
  unsigned int size_in_bytes;
  const char* endianness;
};



/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your MEMORY model.
//* 
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>


#pragma once

#include "model_builder.h"

class MEMORY_machine_arch : public MachineArch { 
    
    public:
    
    public:
        
        ////////////////////////////////////////////////////////////////////
        //   function for port: slave
        ////////////////////////////////////////////////////////////////////
        
        //////
        // functions for port: slave, transaction: READ
        //////
        
        void transaction_instance__slave__READ
          (
            config::uint64 address,
            config::uint64 size,
            config::uint64 data, 
            bool has_been_error, 
            config::uint64 currentTime
          );
        
        //////
        // functions for port: slave, transaction: WRITE
        //////
        
        void transaction_instance__slave__WRITE
          (
            config::uint64 address,
            config::uint64 size,
            config::uint64 data, 
            bool has_been_error, 
            config::uint64 currentTime
          );
        
        
    
    public:
        void configureClock(unsigned portIndex, config::uint64 clock) {
          m_clocks[portIndex] = clock;
        }
        void startTransaction(unsigned portIndex, unsigned transactionIndex, config::uint64 currentTime);
        VariableBase* getVariableBasePtrByName(const char* name);
        Register* getRegisterByName(const char* name);
        virtual void reset();
        
        virtual bool getAddressRange(unsigned portIndex, config::uint64& begin, config::uint64& end);
        
    
    public:
        void callTransaction(unsigned portIndex, unsigned transactionIndex, config::uint64 address, config::uint64 size, config::uint64 data, bool has_been_error, config::uint64 currentTime);
    
    public:
        //constructor
        MEMORY_machine_arch();
    
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The MEMORY_t will be derived from this class.
//*
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>


#pragma once

#include "model_builder.h"
#include "ahb_slave_protocol.h"
 


class MEMORY_t_base : public SystemCBaseModel {
public:
  static MEMORY_t_base* create_t(const char* _name, long simulation);
public:
  MEMORY_t_base(sc_module_name& module_name, long simulation);
 
  enum port_enum {slave};

protected:
  // The following callbacks are called whenever there is a transaction start or end in the port
  // If you want to add your own code (like updating the machine architecture object), 
  // you have to overload these functions in your derived class.

  virtual void accept_ahb_slave_READ
    (long port_index,
     config::int64 time,
     long& burst_size,
     config::uint64 HADDR,
     config::uint64 HRDATA,
     config::uint64 block_size,
     config::uint64& HSIZE) = 0;
  virtual void end_ahb_slave_READ
    (long port_index,
     config::uint64 time,
     long& burst_size,
     config::uint64 HADDR,
     config::uint64 HRDATA,
     config::uint64 block_size,
     config::uint64& HSIZE) = 0;

  virtual void accept_ahb_slave_WRITE
    (long port_index,
     config::int64 time,
     long& burst_size,
     config::uint64 HADDR,
     config::uint64 HWDATA,
     config::uint64 block_size,
     config::uint64& HSIZE) = 0;
  virtual void end_ahb_slave_WRITE
    (long port_index,
     config::uint64 time,
     long& burst_size,
     config::uint64 HADDR,
     config::uint64 HWDATA,
     config::uint64 block_size,
     config::uint64& HSIZE) = 0;


public:
  virtual MEMORY_machine_arch* getMachineArch() const {
    return m_machineArch;
  }

  virtual bool portHasRegisters(unsigned portIndex);
  
  virtual bool triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans);

protected:
  /* schedule functions */
  
protected:
  /* machine architecture */
  MEMORY_machine_arch* m_machineArch;

protected:
  friend class MEMORY_model;
  
  

protected:
  // parameters
  sc_core::sc_time clock;
  sc_core::sc_time ahb_slave_clock;
  double nominal_voltage;
  bool mb_debug;
  bool verbose_parameters;
  unsigned int slave_pipeline_length;
  unsigned int size_in_bytes;
  const char* endianness;

protected:
  long m_simulation;

 
  

  static const unsigned port_count = 1;
  SystemCBaseModel::PortDescription port_descriptions[port_count];
  
  

protected:
  std::vector<esl::sc_sim::pipeline_policy*> m_pipeline_vector;
  std::vector<esl::sc_sim::sequential_policy*> m_sequential_vector;
  std::vector<esl::sc_sim::delay_policy*> m_delay_vector;
  std::vector<esl::sc_sim::uniform_bus_policy*> m_bus_vector;
  std::vector<esl::sc_sim::power_policy*> m_power_vector;
  std::vector<esl::sc_sim::state_power_policy*> m_state_power_vector;
public:
  virtual void update_sync_all();
  virtual void update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle);
  virtual void update_sequential_parameters(esl::sc_sim::sequential_policy* handle);
  virtual void update_delay_parameters(esl::sc_sim::delay_policy* handle);
  virtual void update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle);
  virtual void update_power_parameters(esl::sc_sim::power_policy* handle);
  virtual void update_state_power_parameters(esl::sc_sim::state_power_policy* handle);
protected: /* InterfaceFunctions */
  virtual TransactionCallbackFunctionPointer getTransactionCallback(unsigned callbackIndex);
  config::real80 get_state_power();
protected:

  void start_transaction_ahb_slave_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     config::uint64 startTime,
     config::uint64 endTime,
     config::uint64* parameters,
     bool hasBeenError);
  void end_transaction_ahb_slave_READ
    (esl::include::TRequest* request,
     unsigned port_index,
     config::uint64 startTime,
     config::uint64 endTime,
     config::uint64* parameters,
     bool hasBeenError);
  void start_transaction_ahb_slave_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     config::uint64 startTime,
     config::uint64 endTime,
     config::uint64* parameters,
     bool hasBeenError);
  void end_transaction_ahb_slave_WRITE
    (esl::include::TRequest* request,
     unsigned port_index,
     config::uint64 startTime,
     config::uint64 endTime,
     config::uint64* parameters,
     bool hasBeenError);
};

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for MEMORY.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>

#pragma once

#include "model_builder.h"



 


// forward declaration for pv class
class MEMORY_pv;



class MEMORY_pvt_param_defaults {
  
public:
  MEMORY_pvt_param_defaults(const char* hier_name) {

    sc_core::sc_time clock;
    sc_core::sc_time ahb_slave_clock;
    double nominal_voltage;
    bool mb_debug;
    bool verbose_parameters;
    unsigned int slave_pipeline_length;
    unsigned int size_in_bytes;
    const char* endianness;
    clock = sdInitParameter<sc_core::sc_time>("clock", sc_core::sc_time(10, sc_core::SC_NS), hier_name);
    ahb_slave_clock = sdInitParameter<sc_core::sc_time>("ahb_slave_clock", clock, hier_name);
    nominal_voltage = sdInitParameter<double>("nominal_voltage", 1, hier_name);
    mb_debug = sdInitParameter<bool>("mb_debug", false, hier_name);
    verbose_parameters = sdInitParameter<bool>("verbose_parameters", true, hier_name);
    slave_pipeline_length = sdInitParameter<unsigned int>("slave_pipeline_length", 2, hier_name);
    size_in_bytes = sdInitParameter<unsigned int>("size_in_bytes", 0x10000000, hier_name);
    endianness = sdInitParameter<const char*>("endianness", "host", hier_name);
    sdPropagateParameters();
  }
};

class MEMORY_pvt : public esl::sc_sim::PVTBaseModel, 
                          public mb::utl::cb_owner, 
                          private MEMORY_pvt_param_defaults {

 public:
  typedef MEMORY_pvt self_type;

 public: 
  // Constructor
  MEMORY_pvt(sc_module_name module_name); 
  ~MEMORY_pvt(); 

 public:
    //access the T instance
  inline MEMORY_t_base* getT() const {
    return m_MEMORY_t;
  }
  
  //access the PV instance
  inline MEMORY_pv* getPV() const {
    return m_MEMORY_pv;
  }

  virtual SystemCBaseModel* getSystemCBaseModel() const {
    return getT();
  }

 private:
  void bind();
  


 private:
  //T instance
  MEMORY_t_base* m_MEMORY_t;
  
  //PV instance
  MEMORY_pv* m_MEMORY_pv;

 public:
  // External ports

  typedef esl::sc_sim::pvt_target_socket<32, tlm::tlm_base_protocol_types, 1, sc_core::SC_ONE_OR_MORE_BOUND> slave_type;
  slave_type slave;

 private:
  // PV connection ports

  typedef mb::tlm20::initiator_socket_cb<32> slave_entry_type;
  slave_entry_type slave_entry;     

 private:



  struct slave_nb_connector : public tlm::tlm_bw_nonblocking_transport_if<> {
    MEMORY_pvt& m_owner;
    slave_nb_connector(MEMORY_pvt& owner) : m_owner(owner) {
    }
    virtual tlm::tlm_sync_enum nb_transport_bw(tlm::tlm_generic_payload& trans, 
                                               tlm::tlm_phase& phase, 
                                               sc_core::sc_time& t) {
      return m_owner.slave.nb_transport_bw((tlm::tlm_base_protocol_types::tlm_payload_type&)trans, phase, t);
    }
  };
  friend struct slave_nb_connector;
  slave_nb_connector m_slave_nb_connector;



  tlm::tlm_sync_enum receive_nb_transport_slave(tlm::tlm_generic_payload& trans,
                                                    tlm::tlm_phase& phase,
                                                    sc_core::sc_time& t) {
    return getT()->receive_nb_transport(0, trans, phase, t);
  }

};


