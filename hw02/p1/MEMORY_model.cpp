
/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* This class contains the infrastructure to define the behavior of the component.
//* The MEMORY_pv will be derived from this class.
//*
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>


#include "MEMORY_model.h"

MEMORY_pv_base::MEMORY_pv_base(sc_module_name& module_name) : 
  MEMORY_pv_base_mb_compatibility(module_name),
  VISTA_MB_PV_INIT_MEMBER(slave),
  SD_INITIALIZE_PARAMETER_AS(sc_core::sc_time, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_AS(sc_core::sc_time, ahb_slave_clock, clock),
  SD_INITIALIZE_PARAMETER_AS(double, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_AS(bool, mb_debug, false),
  SD_INITIALIZE_PARAMETER_AS(bool, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_AS(unsigned int, slave_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_AS(unsigned int, size_in_bytes, 0x10000000),
  SD_INITIALIZE_PARAMETER_AS(const char*, endianness, "host") { 
  payload_on_stack = 0;

  VISTA_MB_PV_BIND_FW_PROCESS_TO_TARGET(slave);
  VISTA_MB_PV_REGISTER_SELF_FW_PROCESS_CALLBACKS(slave);

  if(verbose_parameters) print_parameters();
}

void MEMORY_pv_base::print_parameters()
{
  const char* name;
  if (!strcmp(this->basename(), "PV"))
    name = this->get_parent()->name();
  else
    name = this->name();

  std::cout.setf(ios::hex, ios::basefield);
  std::cout.setf(ios::showbase);
  std::cout << name << "::parameters:\n";
  std::cout << "\tclock = " << clock << "\n";
  std::cout << "\tahb_slave_clock = " << ahb_slave_clock << "\n";
  std::cout << "\tnominal_voltage = " << nominal_voltage << "\n";
  std::cout << "\tmb_debug = " << mb_debug << "\n";
  std::cout << "\tverbose_parameters = " << verbose_parameters << "\n";
  std::cout << "\tslave_pipeline_length = " << slave_pipeline_length << "\n";
  std::cout << "\tsize_in_bytes = " << size_in_bytes << "\n";
  std::cout << "\tendianness = " << endianness << "\n";
  std::cout.unsetf(ios::showbase);
  std::cout.setf(ios::dec, ios::basefield);
  std::cout << std::endl;
}

/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file is used only for learning the component.
//* It contains the machine architecture class for your MEMORY model.
//* 
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>

#include "MEMORY_model.h"
#include "model_builder.h"

using namespace ::mb::utl::minmax;

MEMORY_machine_arch::MEMORY_machine_arch()
    : MachineArch(1, 0) {
        reset();
    }
    
    ////////////////////////////////////////////////////////////////////
    //   function for port: slave
    ////////////////////////////////////////////////////////////////////
    
    
    //////
    // functions for port: slave, transaction: READ
    //////
    
    void MEMORY_machine_arch::transaction_instance__slave__READ
      (
        config::uint64 address,
        config::uint64 size,
        config::uint64 data, 
        bool has_been_error, 
        config::uint64 currentTime
      )
    {
      
    }
    
    //////
    // functions for port: slave, transaction: WRITE
    //////
    
    void MEMORY_machine_arch::transaction_instance__slave__WRITE
      (
        config::uint64 address,
        config::uint64 size,
        config::uint64 data, 
        bool has_been_error, 
        config::uint64 currentTime
      )
    {
      
    }

void MEMORY_machine_arch::startTransaction(unsigned portIndex, unsigned transactionIndex, config::uint64 currentTime) {
  switch(portIndex) {
    case(0) : break;
  }
}
VariableBase* MEMORY_machine_arch::getVariableBasePtrByName(const char* name) {
  return NULL;
}
Register* MEMORY_machine_arch::getRegisterByName(const char* name) {
  return 0;
}
void MEMORY_machine_arch::reset() { 
    MachineArch::reset();
}
bool MEMORY_machine_arch::getAddressRange(unsigned portIndex, config::uint64& begin, config::uint64& end) {
    switch(portIndex) {
        case(0) :   return false;
    }
    return false; 
}
void MEMORY_machine_arch::callTransaction(unsigned portIndex, unsigned transactionIndex, config::uint64 address, config::uint64 size, config::uint64 data, bool has_been_error, config::uint64 currentTime) {
    switch(portIndex) {
        case(0) : { //port: slave
            switch(transactionIndex) {
                case(0) : { //transaction: READ
                    this->transaction_instance__slave__READ
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
                case(1) : { //transaction: WRITE
                    this->transaction_instance__slave__WRITE
                      (
                        address, 
                        size, 
                        data, 
                        has_been_error, 
                        currentTime
                      );
                    break;
                }
            }
            break;
        }
    }
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected. 
//* DO NOT MODIFY THIS FILE.
//*
//* This file is generated according to the parameters in the 
//* Model Builder form.
//* 
//* Any change in parameters, policies, ports, protocols, etc. will change this file
//* upon generation of the timing model (using generate_timing_model command).
//* The MEMORY_t will be derived from this class.
//*
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>




#include "MEMORY_model.h"
#include <math.h>
#include <stdlib.h>

using namespace esl::tlm_sim;
using namespace esl::sc_sim;




void MEMORY_t_base::start_transaction_ahb_slave_READ
(esl::include::TRequest* request,
 unsigned port_index,
 config::uint64 startTime,
 config::uint64 endTime,
 config::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           0,
                                           startTime);
  
  this->accept_ahb_slave_READ
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3]);
}

void MEMORY_t_base::end_transaction_ahb_slave_READ
(esl::include::TRequest* request,
 unsigned port_index,
 config::uint64 startTime,
 config::uint64 endTime,
 config::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          0, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_ahb_slave_READ
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3]);
}
void MEMORY_t_base::start_transaction_ahb_slave_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 config::uint64 startTime,
 config::uint64 endTime,
 config::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();
  
  this->getMachineArch()->startTransaction(port_index,
                                           1,
                                           startTime);
  
  this->accept_ahb_slave_WRITE
    (port_index, 
     startTime, 
     burstSize, 
     parameters[0], 
     parameters[1], 
     parameters[2], 
     parameters[3]);
}

void MEMORY_t_base::end_transaction_ahb_slave_WRITE
(esl::include::TRequest* request,
 unsigned port_index,
 config::uint64 startTime,
 config::uint64 endTime,
 config::uint64* parameters,
 bool hasBeenError) {
  long burstSize = request->getSize();
  parameters[0] = request->getAddress();
  parameters[1] = request->getFirstDataBlock();
  parameters[2] = request->getBlockSize();                                                                         
  this->getMachineArch()->callTransaction(port_index, 
                                          1, 
                                          request->getAddress(),
                                          burstSize,
                                          request->getFirstDataBlock(),
                                          hasBeenError,
                                          startTime);
  
  this->end_ahb_slave_WRITE
    (port_index,
     endTime,
     burstSize,
     parameters[0],
     parameters[1],
     parameters[2],
     parameters[3]);
}

MEMORY_t_base::TransactionCallbackFunctionPointer MEMORY_t_base::getTransactionCallback(unsigned callbackIndex) {
  static TransactionCallbackFunctionPointer funcArray[] = {
    static_cast<TransactionCallbackFunctionPointer>(&MEMORY_t_base::start_transaction_ahb_slave_READ),
    static_cast<TransactionCallbackFunctionPointer>(&MEMORY_t_base::start_transaction_ahb_slave_WRITE),
    static_cast<TransactionCallbackFunctionPointer>(&MEMORY_t_base::end_transaction_ahb_slave_READ),
    static_cast<TransactionCallbackFunctionPointer>(&MEMORY_t_base::end_transaction_ahb_slave_WRITE),
    0
  };
  if(callbackIndex >= sizeof(funcArray) / sizeof(*funcArray) - 1)
    return 0;
  return funcArray[callbackIndex];
}




MEMORY_t_base::MEMORY_t_base(sc_module_name& module_name, long simulation) :
  SystemCBaseModel(module_name),
  m_machineArch(new MEMORY_machine_arch()),
  SD_INITIALIZE_PARAMETER_AS(sc_core::sc_time, clock, sc_core::sc_time(10, sc_core::SC_NS)),
  SD_INITIALIZE_PARAMETER_AS(sc_core::sc_time, ahb_slave_clock, clock),
  SD_INITIALIZE_PARAMETER_AS(double, nominal_voltage, 1),
  SD_INITIALIZE_PARAMETER_AS(bool, mb_debug, false),
  SD_INITIALIZE_PARAMETER_AS(bool, verbose_parameters, true),
  SD_INITIALIZE_PARAMETER_AS(unsigned int, slave_pipeline_length, 2),
  SD_INITIALIZE_PARAMETER_AS(unsigned int, size_in_bytes, 0x10000000),
  SD_INITIALIZE_PARAMETER_AS(const char*, endianness, "host"),
  m_simulation(simulation)
{
  bool separate_read_channel = false;
  bool separate_write_channel = false;
  fix_clock_parameter(ahb_slave_clock, "ahb_slave_clock");
  separate_read_channel = false;
  separate_write_channel = false;
  port_descriptions[slave].port_name = "slave";
  port_descriptions[slave].port_kind = PortDescription::READ_WRITE_CHANNEL_PORT;
  if (separate_write_channel && separate_read_channel)
    port_descriptions[slave].port_kind = PortDescription::SEPARATE_READ_WRIE_CHANNEL_PORT;
  port_descriptions[slave].is_read_write_address_channel = 0;
  
  port_descriptions[slave].is_read_write_address_channel = 1;
  port_descriptions[slave].is_master_port = 0;
  port_descriptions[slave].is_signal_port = 0;
  port_descriptions[slave].port_width = 4;
  port_descriptions[slave].protocol_name = "ahb_slave";
  port_descriptions[slave].params_count = 11;
  port_descriptions[slave].clock = ahb_slave_clock;
  m_machineArch->configureClock(slave, mb::sysc::sc_time_to_ps(ahb_slave_clock));
  port_descriptions[slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_REQ), !0, 1);
  port_descriptions[slave].add_read_phase(tlm::tlm_phase(tlm::BEGIN_RESP), !1, 1);


  port_descriptions[slave].default_read_transaction_name = "READ";
  port_descriptions[slave].default_write_transaction_name = "WRITE";

  fix_internal_clock_parameter(clock, "clock");
  set_ports(mb::sysc::sc_time_to_ps(clock), port_count, port_descriptions);

  bool isCpu = false;
  
  esl::tlm_sim::UserRunningModel* userRunningModel = Papoulis_CreateUserRunningModel(name(),
                                                                                     0,
                                                                                     this,
                                                                                     simulation,
                                                                                     false,
                                                                                     isCpu);
  setUserRunningModel(userRunningModel);
  set_nominal_voltage(nominal_voltage);
  set_sync_all(0);
  set_sync_all(0);
  
  
  
  

  
  

  delay_policy* delay_policy_handle = 0;

  delay_policy_handle = new delay_policy(userRunningModel,
                                         "slave.READ",
                                         5,
                                         0,
                                         mb::tlm20::NO_SYNC);
  delay_policy_handle->set_power(30);
  m_delay_vector.push_back(delay_policy_handle);
  delay_policy_handle = new delay_policy(userRunningModel,
                                         "slave.WRITE",
                                         3,
                                         0,
                                         mb::tlm20::NO_SYNC);
  delay_policy_handle->set_power(40);
  m_delay_vector.push_back(delay_policy_handle);

  

  constant_global_power_policy* p = new constant_global_power_policy(userRunningModel);
  p->set_leakage_power(0.05);
  p->set_direct_clock_power(1);
  set_nominal_clock(1000000/100); /* in ps */ 
  update_coefficients();
  set_global_power_policy(p);
}

void MEMORY_t_base::update_sync_all() {
  set_sync_all(0);
  set_sync_all(0);
}

void MEMORY_t_base::update_pipeline_parameters(esl::sc_sim::pipeline_policy* handle) {
  if (m_pipeline_vector.size() == 0)
    return;


}

void MEMORY_t_base::update_sequential_parameters(esl::sc_sim::sequential_policy* handle) {
  if (m_sequential_vector.size() == 0)
    return;

}

void MEMORY_t_base::update_delay_parameters(esl::sc_sim::delay_policy* handle) {
  if (m_delay_vector.size() == 0)
    return;

  if (handle == m_delay_vector[0]) {
    handle->set_inner_delay(5);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::NO_SYNC);
    handle->set_power(30);
    return;
  }
  if (handle == m_delay_vector[1]) {
    handle->set_inner_delay(3);
    handle->set_start_delay(0);
    handle->setSyncMode(mb::tlm20::NO_SYNC);
    handle->set_power(40);
    return;
  }
}

void MEMORY_t_base::update_bus_parameters(esl::sc_sim::uniform_bus_policy* handle) {
  if (m_bus_vector.size() == 0)
    return;

}

void MEMORY_t_base::update_power_parameters(esl::sc_sim::power_policy* handle) {
  if (m_power_vector.size() == 0)
    return;

}

void MEMORY_t_base::update_state_power_parameters(esl::sc_sim::state_power_policy* handle) {
  if (m_state_power_vector.size() == 0)
    return;

}


bool MEMORY_t_base::triggerRegistersGotHit(unsigned portIndex, tlm::tlm_generic_payload& trans) {
  mb::utl::Segment<uint64_t> transactionRange(trans.get_address(), trans.get_address() + trans.get_data_length());

  return false;
}

bool MEMORY_t_base::portHasRegisters(unsigned portIndex) {
  switch (portIndex) {

  }
  return false;
}


/**************************************************************/
/*                                                            */
/*      Copyright Mentor Graphics Corporation 2006 - 2011     */
/*                  All Rights Reserved                       */
/*                                                            */
/*       THIS WORK CONTAINS TRADE SECRET AND PROPRIETARY      */
/*         INFORMATION WHICH IS THE PROPERTY OF MENTOR        */
/*         GRAPHICS CORPORATION OR ITS LICENSORS AND IS       */
/*                 SUBJECT TO LICENSE TERMS.                  */
/*                                                            */
/**************************************************************/

//*<
//* Generated By Model Builder, Mentor Graphics Computer Systems, Inc.
//*
//* This file is write protected.
//* DO NOT MODIFY THIS FILE.
//*
//* This file contains the PVT class for MEMORY.
//* It connects between the PV and T models.
//* Your top-level design should instantiate this model.
//* 
//* In order to synchronize the activty between the PV and the T models, every 
//* PV transaction is monitored and queued in the T sync ports.
//* Whenever a synchronization point is reached, the T models are executed and 
//* the corresponding T transactions are launched.
//* A synchronization point is reached whenever there is a wait statement on a testbench thread. 
//*
//* Model Builder version: 3.1.1
//* Generated on: Jan. 05, 2012 04:09:46 PM, (user: wdavis)
//*>

#include "MEMORY_model.h"


#include "MEMORY_pv.h"

// Constructor
MEMORY_pvt::MEMORY_pvt(sc_module_name module_name)
  : esl::sc_sim::PVTBaseModel(module_name, 0),
    MEMORY_pvt_param_defaults(this->name()),
    slave("slave"),
    slave_entry("unvisible_slave_entry"),
    m_slave_nb_connector(*this)
{
  m_MEMORY_t = MEMORY_t_base::create_t("T", 1);
  m_MEMORY_pv = new MEMORY_pv("PV");
  bind();
}

MEMORY_pvt::~MEMORY_pvt() {
  delete m_MEMORY_t; delete m_MEMORY_pv;
}



void MEMORY_pvt::bind()
{
  /* connect pv to entry ports */
  slave_entry.bind(getPV()->slave);   

  /* set callbacks on external and entry ports */ 

  slave.b_transport_cb.set(&slave_entry, &slave_entry_type::b_transport);
  slave.transport_dbg_cb.set(&slave_entry, &slave_entry_type::transport_dbg);
  slave.get_direct_mem_ptr_cb.set(&slave_entry, &slave_entry_type::get_direct_mem_ptr);

  
  /* connect t non blocking callbacks */

  slave.nb_transport_fw_cb.set(this, &self_type::receive_nb_transport_slave);
  getT()->set_port_cb(0, &m_slave_nb_connector);

  slave_entry.invalidate_direct_mem_ptr_cb.set(&slave, &slave_type::invalidate_direct_mem_ptr);

}


